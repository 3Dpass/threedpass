import 'dart:convert';

import 'package:threedp_graphql/features/tokens_events_history/data/query/__generated__/get_tokens_events.data.gql.dart';
import 'package:threedpass/core/polkawallet/app_service.dart';
import 'package:threedpass/core/polkawallet/utils/encode_address.dart';
import 'package:threedpass/features/wallet_screen/presentation/non_native_token_screen/domain/entities/non_native_token_create.dart';
import 'package:threedpass/features/wallet_screen/presentation/non_native_token_screen/domain/entities/non_native_token_mint.dart';
import 'package:threedpass/features/wallet_screen/presentation/non_native_token_screen/domain/entities/non_native_token_set_meta_data.dart';
import 'package:threedpass/features/wallet_screen/presentation/non_native_token_screen/domain/entities/non_native_token_unknown.dart';

abstract class NonNativeTokenHistoryAtomBase {
  const NonNativeTokenHistoryAtomBase({
    required this.blockDatetime,
    required this.extrinsicIdx,
    required this.authorAddress,
  });

  final DateTime blockDatetime;
  final int extrinsicIdx;
  final String authorAddress;

  NonNativeTokenExtrinsicType get extrinsicType;

  static Future<NonNativeTokenHistoryAtomBase> fromAutoGeneratedObject(
    final GGetExtrinsicsData_getExtrinsics_objects autoGeneratedObject,
    final AppService appService,
  ) async {
    final service = appService.plugin.sdk.api.account.service;
    final ss58Format = appService.networkStateData.ss58Format;
    // autoGeneratedObject.callArguments
    // final fromAccountId = autoGeneratedObject.cal;
    // final toAccountId = autoGeneratedObject.toMultiAddressAccountId;

    final a1 = autoGeneratedObject.callArguments;
    final a2 = jsonDecode(a1!.value);

    final date = DateTime.parse(autoGeneratedObject.blockDatetime?.value ?? '');
    final extrinsicIdx = autoGeneratedObject.extrinsicIdx ?? -1;
    final authorAddress = await appService.encodeAddress(
      autoGeneratedObject.multiAddressAccountId ?? '',
    );

    switch (autoGeneratedObject.callName) {
      case 'create':
        return NonNativeTokenCreate(
          blockDatetime: date,
          extrinsicIdx: extrinsicIdx,
          authorAddress: authorAddress,
        );
      case 'set_metadata':
        return NonNativeTokenSetMetaData(
          blockDatetime: date,
          extrinsicIdx: extrinsicIdx,
          authorAddress: authorAddress,
        );
      case 'mint':
        return NonNativeTokenMint(
          blockDatetime: date,
          extrinsicIdx: extrinsicIdx,
          authorAddress: authorAddress,
          // value: a2[2]['value'],
          value: 'a',
        );
      case 'transfer_keep_alive':
      // final assetId = 1; // TODO Get asset id from json
      // final tokenBalanceData = appService.plugin.balances.tokens
      //     .firstWhere((element) => element.id == assetId);
      // final isFrom = authorAddress == appService.keyring.current.address;

      // break;
      default:
        return NonNativeTokenUnkown(
          blockDatetime: date,
          extrinsicIdx: extrinsicIdx,
          authorAddress: authorAddress,
          arguments: autoGeneratedObject.callArguments?.value ?? '',
          callModule: autoGeneratedObject.callModule ?? '',
        );
      // break;
    }

    // String? fromAddress;
    // String? toAddress;

    // try {
    //   final d1 = await service.encodeAddress([toAccountId!], [ss58Format]);
    //   toAddress = d1![ss58Format.toString()][toAccountId] as String;
    // } on Object {
    //   toAddress = null;
    // }

    // return TransferNonNativeTokenAtom._(
    //   autoGeneratedObject,
    //   amount: '1000000000000',
    //   isFrom: false,
    //   fromAddress: fromAddress,
    //   toAddress: toAddress,
    //   symbol: 'aaa',
    // );
  }
}

// final GGetExtrinsicsData_getExtrinsics_objects autoGeneratedObject;
// final String? fromAddress;
// final String? toAddress;
// final String amount;
// final String symbol;
// final bool isFrom;

// const TransferNonNativeTokenAtom._(
//   this.autoGeneratedObject, {
//   required this.amount,
//   required this.isFrom,
//   required this.symbol,
//   this.fromAddress,
//   this.toAddress,
// });

enum NonNativeTokenExtrinsicType {
  create,
  set_metadata,
  mint,
  transfer,
  unknown,
}
